y////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
///
/// THIS FILE IS AUTOMATICALLY GENERATED !! DO NOT MODIFY !!
///

#include "umbc/text_utils.h"
#include "mcl_symbols.h"
#include <string.h>
#include <errno.h>

using namespace std;
using namespace metacog::symbols;

symbol_table metacog::symbols::__mcl_global_symtable("global_symtable");

void symbol_table::symbol_def(string name, int val) {
  intmap[name]=val;
  dblmap[name]=(double)val;
}

void symbol_table::symbol_def(string name, double val) {
  intmap[name]=(int)val;
  dblmap[name]=val;
}

string symbol_table::reverse_lookup(string prefix, int value,
				    bool* none, bool* multi) {
  bool nonev=true,multiv=false;
  string rv="";
  for (map<string,int>::iterator mi = intmap.begin();
       mi != intmap.end();
       mi++) {
    if ((mi->second == value) &&
	(strncmp((mi->first).c_str(),prefix.c_str(),prefix.size()) == 0)) {
      if (nonev) {
	rv=mi->first;
	nonev=false;
      }
      else 
	multiv=true;
    }
  }
  if (none) *none=nonev;
  if (multi) *multi=multiv;
  return rv;
}

int symbol_table::symbol_intval(string name,bool* exists) {
  map<string,int>::iterator iter = intmap.find(name);
  if (iter != intmap.end()) {
    *exists = true;
    return iter->second;
  }
  else {
    *exists = false;
    return 0;
  }
}

int symbol_table::symbol_intval(string name) {
  return intmap[name];
}

double symbol_table::symbol_dblval(string name,bool* exists) {
  map<string,double>::iterator iter = dblmap.find(name);
  if (iter != dblmap.end()) {
    *exists = true;
    return iter->second;
  }
  else {
    *exists = false;
    return 0;
  }
}

double symbol_table::symbol_dblval(string name) {
  return dblmap[name];
}

int metacog::symbols::global_symbol_intval(string name,bool* exists) {
  return __mcl_global_symtable.symbol_intval(name,exists);
}

int metacog::symbols::global_symbol_intval(string name) {
  return __mcl_global_symtable.symbol_intval(name);
}

void metacog::symbols::global_symbol_def(string name,int val) {
  __mcl_global_symtable.symbol_def(name,val);
}

double metacog::symbols::global_symbol_dblval(string name,bool* exists) {
  return __mcl_global_symtable.symbol_dblval(name,exists);
}

double metacog::symbols::global_symbol_dblval(string name) {
  return __mcl_global_symtable.symbol_dblval(name);
}

void metacog::symbols::global_symbol_def(string name,double val) {
  __mcl_global_symtable.symbol_def(name,val);
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
///
/// SYMTABLE CONTRUCTOR -- GENERATES DEFAULT MCL SYMBOLS...
///



metacog::symbols::symbol_table::symbol_table(string name) :tname(name) {
  symbol_def("missing_float_value",MISSING_FLOAT_VALUE);
  
    symbol_def("pci_min_index",PCI_MIN_INDEX);
  symbol_def("pci_intentional",PCI_INTENTIONAL);
  symbol_def("pci_effectors_can_fail",PCI_EFFECTORS_CAN_FAIL);
  symbol_def("pci_sensors_can_fail",PCI_SENSORS_CAN_FAIL);
  symbol_def("pci_parameterized",PCI_PARAMETERIZED);
  symbol_def("pci_declarative",PCI_DECLARATIVE);
  symbol_def("pci_retrainable",PCI_RETRAINABLE);
  symbol_def("pci_hlc_controlling",PCI_HLC_CONTROLLING);
  symbol_def("pci_htn_in_play",PCI_HTN_IN_PLAY);
  symbol_def("pci_plan_in_play",PCI_PLAN_IN_PLAY);
  symbol_def("pci_action_in_play",PCI_ACTION_IN_PLAY);
  symbol_def("pci_max",PCI_MAX);
  symbol_def("pci_count",PCI_COUNT);
  
    symbol_def("crc_min_index",CRC_MIN_INDEX);
  symbol_def("crc_ignore",CRC_IGNORE);
  symbol_def("crc_noop",CRC_NOOP);
  symbol_def("crc_try_again",CRC_TRY_AGAIN);
  symbol_def("crc_solicit_help",CRC_SOLICIT_HELP);
  symbol_def("crc_relinquish_control",CRC_RELINQUISH_CONTROL);
  symbol_def("crc_sensor_diag",CRC_SENSOR_DIAG);
  symbol_def("crc_effector_diag",CRC_EFFECTOR_DIAG);
  symbol_def("crc_sensor_reset",CRC_SENSOR_RESET);
  symbol_def("crc_effector_reset",CRC_EFFECTOR_RESET);
  symbol_def("crc_activate_learning",CRC_ACTIVATE_LEARNING);
  symbol_def("crc_adj_params",CRC_ADJ_PARAMS);
  symbol_def("crc_rebuild_models",CRC_REBUILD_MODELS);
  symbol_def("crc_revisit_assumptions",CRC_REVISIT_ASSUMPTIONS);
  symbol_def("crc_amend_controller",CRC_AMEND_CONTROLLER);
  symbol_def("crc_revise_expectations",CRC_REVISE_EXPECTATIONS);
  symbol_def("crc_alg_swap",CRC_ALG_SWAP);
  symbol_def("crc_change_hlc",CRC_CHANGE_HLC);
  symbol_def("crc_rescue",CRC_RESCUE);
  symbol_def("crc_give_up",CRC_GIVE_UP);
  
  symbol_def("crc_extended_code",CRC_EXTENDED_CODE);
  
  symbol_def("crc_pcv_maxindex",CRC_PCV_MAXINDEX);
  symbol_def("pc_vector_length",PC_VECTOR_LENGTH);
  symbol_def("crc_max",CRC_MAX);
  
    
  symbol_def("pc_yes",PC_YES);
  symbol_def("pc_no",PC_NO);
  
/* expectation codes */
  symbol_def("ec_illegal",EC_ILLEGAL);
  
    
/* maintenance */
  symbol_def("ec_stayunder",EC_STAYUNDER);
  symbol_def("ec_stayover",EC_STAYOVER);
  symbol_def("ec_maintainvalue",EC_MAINTAINVALUE);
  symbol_def("ec_withinnormal",EC_WITHINNORMAL);
  
  symbol_def("ec_ratio_maintain",EC_RATIO_MAINTAIN);
  symbol_def("ec_ratio_stayunder",EC_RATIO_STAYUNDER);
  symbol_def("ec_ratio_stayover",EC_RATIO_STAYOVER);
  
  symbol_def("ec_realtime",EC_REALTIME);
  symbol_def("ec_ticktime",EC_TICKTIME);
  
/* effects     */
  symbol_def("ec_go_up",EC_GO_UP);
  symbol_def("ec_go_down",EC_GO_DOWN);
  symbol_def("ec_net_zero",EC_NET_ZERO);
  symbol_def("ec_any_change",EC_ANY_CHANGE);
  symbol_def("ec_net_range",EC_NET_RANGE);
  symbol_def("ec_take_value",EC_TAKE_VALUE);
  
  symbol_def("ec_dont_care",EC_DONT_CARE);
  symbol_def("ec_be_legal",EC_BE_LEGAL);
  
/* data types     */
    symbol_def("dt_integer",DT_INTEGER);
  symbol_def("dt_rational",DT_RATIONAL);
  symbol_def("dt_binary",DT_BINARY);
  symbol_def("dt_bitfield",DT_BITFIELD);
  symbol_def("dt_symbol",DT_SYMBOL);
  
/* sensor codes   */
    symbol_def("sc_state",SC_STATE);
  symbol_def("sc_control",SC_CONTROL);
  symbol_def("sc_spatial",SC_SPATIAL);
  symbol_def("sc_temporal",SC_TEMPORAL);
  symbol_def("sc_resource",SC_RESOURCE);
  symbol_def("sc_reward",SC_REWARD);
  symbol_def("sc_ambient",SC_AMBIENT);
  symbol_def("sc_objectprop",SC_OBJECTPROP);
  symbol_def("sc_message",SC_MESSAGE);
  symbol_def("sc_counter",SC_COUNTER);
  symbol_def("sc_unspec",SC_UNSPEC);
  symbol_def("sc_numcodes_legal",SC_NUMCODES_LEGAL);
  
/* noise profiles */
    symbol_def("mcl_np_no_profile",MCL_NP_NO_PROFILE);
  symbol_def("mcl_np_perfect",MCL_NP_PERFECT);
  symbol_def("mcl_np_uniform",MCL_NP_UNIFORM);
  symbol_def("mcl_np_automatic",MCL_NP_AUTOMATIC);
  symbol_def("mcl_np_default",MCL_NP_DEFAULT);
  
  /* property code indexes (into the prop vector) */
  symbol_def("prop_dt",PROP_DT);
  symbol_def("prop_sclass",PROP_SCLASS);
  symbol_def("prop_noiseprofile",PROP_NOISEPROFILE);
  symbol_def("prop_count",PROP_COUNT);
  symbol_def("number_of_sensor_props",NUMBER_OF_SENSOR_PROPS);
  
/* miscellaneous defines ... */
  symbol_def("resref_no_reference",RESREF_NO_REFERENCE);
  symbol_def("egk_no_eg",EGK_NO_EG);
  symbol_def("egk_base_level",EGK_BASE_LEVEL);
  
    symbol_def("relation_equal",RELATION_EQUAL);
  symbol_def("relation_gt",RELATION_GT);
  symbol_def("relation_lt",RELATION_LT);
  symbol_def("relation_gte",RELATION_GTE);
  symbol_def("relation_lte",RELATION_LTE);
  
}

int metacog::symbols::smartval_int(string specifier, bool* error) {
  int rv = -1;
  { // try symbol stuff first
    bool exists;
    rv = global_symbol_intval(specifier,&exists);
    if (exists) {
      if (error) *error = false;
      return rv;
    }
    else { // now try textFunctions
      int rv = umbc::textFunctions::numval(specifier.c_str());
      if (errno == 0) {
	if (error) *error=false;
	return rv;
      }
      else {
	if (error) *error=true;
	return -1;
      }
    }
  }
}

  /*
  int rv = umbc::textFunctions::numval(specifier.c_str());
  if (errno == 0) {
    if (error) *error=false;
    return rv;
  }
  else {
    bool exists;
    rv = global_symbol_intval(specifier,&exists);
    if (error) *error = !exists;
    return rv;
  }
  */

string metacog::symbols::reverse_lookup(string prefix, int value, 
					bool* none, bool* multi) {
  return __mcl_global_symtable.reverse_lookup(prefix,value,none,multi);
}

// end?


